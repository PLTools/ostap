<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Extension (ostap.Pa_ostap.Extension)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.4"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">ostap</a> &#x00BB; <a href="../index.html">Pa_ostap</a> &#x00BB; Extension</nav><header class="odoc-preamble"><h1>Module <code><span>Pa_ostap.Extension</span></code></h1><p>Pa_ostap --- a camlp5 syntax extension for BNF-like grammar definitions.</p></header><nav class="odoc-toc"><ul><li><a href="#general-description">General description</a></li><li><a href="#parse-expressions">Parse expressions</a></li><li><a href="#rules">Rules</a></li><li><a href="#documentation-generation">Documentation generation</a></li></ul></nav><div class="odoc-content"><h3 id="general-description"><a href="#general-description" class="anchor"></a>General description</h3><p><code>Pa_ostap</code> extends Objective Caml grammar with construct <code>ostap (..)</code>, introduced at structure and expression levels. The exact allowed forms are the following:</p><ol><li><code>ostap</code> <i>doc_tag</i> <code>(</code><i>rules</i><code>)</code> --- at the structure (module implementation) level;</li><li><code>let ostap</code> <i>doc_tag</i> <code>(</code><i>rule</i><code>)</code> --- at the let-binding level; introduces <i>recursive</i> binding;</li><li><code>ostap</code> <i>doc_tag</i> <code>(</code><i>rules</i><code>)</code> --- at the expression level;</li><li><code>ostap</code> <code>(</code><i>parse_expr</i><code>)</code> --- at the expression level;</li><li><code>let ostap</code> <i>doc_tag</i> <code>(</code><i>rules</i><code>) in</code> <i>expr</i> --- at the expression level;</li></ol><p>In the specification above <i>rules</i> denotes a sequence of grammar rules, <i>rule</i> --- a single rule, <i>parse_expr</i> --- parse expression, <i>doc_tag</i> --- documentation specifier. Below the examples of all these constructs are given:</p><pre class="language-ocaml"><code>(* Grammar rules specification at the structure level; rules are mutually recursive *)
ostap (
  x: IDENT; (* rule defining parser x *)
  y: CONST  (* rule defining parser y *)
)

(* Grammar rule at the let-binding level; bindings are mutually recursive *)
let ostap (x: IDENT) (* rule defining parser x *)
and ostap (y: CONST) (* rule defining parser y *)
and u = 3            (* an example to demonstrate interoperability with other let-bindings *)

let _ =
  (* Let-bindings at expression level; x and y are mutually recursive *)
  let ostap (x: IDENT; y: CONST) in
  (* Grammar expression *)
  let p = ostap (x y) in
  ()</code></pre><p>All these constructs are converted into pure OCaml using <code>Ostap</code> parser combinators.</p><p>While <code>Ostap</code> is purely abstract with regard to stream implementation <code>Pa_ostap</code> additionally provides convenient integration of parsing and lexing by considering <i>streams as objects</i>. Namely, the stream of tokens <code>L</code><sub>1</sub>, <code>L</code><sub>2</sub>, ..., <code>L</code><sub>k</sub> is represented by an object with member functions <code>getL</code><sub>1</sub>, <code>getL</code><sub>2</sub>, ..., <code>getL</code><sub>k</sub>. Such a representation allows to freely combine various parser functions that operate on different types of streams with almost no type limitations at construction time.</p><p>Additionally to this documentation we provide a closed example of how to use <code>Pa_ostap</code> (see <code>sample</code> directory of the distribution).</p><h3 id="parse-expressions"><a href="#parse-expressions" class="anchor"></a>Parse expressions</h3><p>The syntax of parse expressions is as follows (text in <b>bold</b> denotes meta-language syntax description symbols):</p><p><code>parse_expr</code> <b>:</b> <code>alternative</code><sub><code>1</code></sub> <b>|</b> <code>alternative</code><sub><code>2</code></sub> <b>| ... |</b> <code>alternative</code><sub><code>k</code></sub></p><p><code>alternative</code> <b>:</b> <code>prefixed+</code> <b>[</b> <code>semantic</code> <b>]</b></p><p><code>prefixed</code> <b>:</b> <b>[</b> <code>-</code> <b>]</b> <code>basic</code></p><p><code>basic</code> <b>:</b> <b>[</b> <code>binding</code> <b>]</b> <code>postfix</code> <b>[</b> <code>predicate</code> <b>]</b></p><p><code>postfix</code> <b>:</b> <code>primary</code> <b>|</b> <code>postfix</code> <b>(</b> <code>*</code> <b>[</b> folding <b>]</b> <b>|</b> <code>+</code> <b>[</b> folding <b>]</b> <b>|</b> <code>?</code> <b>|</b> <code>:: (</code> <i>EXPR</i> <code>)</code> <b>)</b></p><p><code>folding</code> <b>:</b> <b>with</b> <b>{</b> <i>EXPR</i> <b>}</b> <b>{</b> <i>EXPR</i> <b>}</b></p><p><code>primary</code> <b>:</b> <i>UIDENT</i> <b>|</b> <code>parser</code> <b>[</b> <code>parameters</code> <b>]</b> <b>|</b> <code>string</code> <b>|</b> <code>$</code> <b>| (</b> <code>parse_expr</code> <b>)</b></p><p><code>parser</code> <b>:</b> <i>LIDENT</i> <b>|</b> <code>!(</code><i>EXPR</i><code>)</code></p><p><code>string</code> <b>:</b> <i>STRING</i> <b>|</b> <code>$(</code><i>EXPR</i><code>)</code></p><p><code>parameters</code> <b>:</b> <b>(</b><code>[</code> <i>EXPR</i> <code>]</code><b>)*</b></p><p><code>binding</code> <b>:</b> <i>PATT</i> <code>:</code></p><p><code>predicate</code> <b>:</b> <code>=&gt; {</code> <i>EXPR</i> <code>}</code> <b>[</b> <code>::(</code> <i>EXPR</i> <code>)</code><b>]</b> <code>=&gt;</code></p><p><code>semantic</code> <b>:</b> <code>{</code> <i>EXPR</i> <code>}</code></p><p>Here <i>UIDENT</i> and <i>LIDENT</i> stand for identifiers starting from uppercase and lowercase letters correspondingly, <i>STRING</i> --- for OCaml strings, <i>EXPR</i> --- for OCaml expression, <i>PATT</i> --- for OCaml pattern.</p><p><code>parser</code> within parse expression denotes a <i>parse function</i> that applied to a stream to obtain parsed value and residual stream (see module <code>Ostap.Combinators</code>). Each reference is either a <i>LIDENT</i> or arbitrary OCaml expression of appropriate type, surrounded by <code>!(...)</code>. Parser invocation may be equipped with parameters each of which has to be surrounded by <code>[...]</code> (partial application is allowed as well). <i>UIDENT</i> is treated as a lexeme reference; thought generally speaking parsing with <code>Ostap</code> does not require any lexer to be provided (you may instead supply a set of basic parse functions in any way you find convenient) <code>Pa_ostap</code> additionally operates with some predefined representation of streams as objects (see module <code>Matcher</code>). This representation does not interfere with the common approach and you need not use this feature unless you explicitly apply to it. There are only three constructs that refer to object implementation of streams: <i>UIDENT</i>, <code>$(</code><i>EXPR</i><code>)</code> and <i>STRING</i>. If you use <i>UIDENT</i> in grammar expression, for example <i>NAME</i>, then the stream to parse with this expression has to provide a member function <i>getNAME</i>. Similarly using <i>STRING</i> in expression requires stream to provide a member <i>look</i>. Finally you may match a stream against value of any OCaml expression of string type by surrounding it with <code>$(...)</code>.</p><p>Postfix operators <code>+</code>, <code>*</code> and <code>?</code> denote respectively one-or-more iteration, zero-or-more iteration and optional value. Postfix operator <code>::(</code><i>EXPR</i><code>)</code> can be used to <i>comment</i> the reason returned on failure with the given reason value (see <a href="../../Ostap/Combinators/index.html#val-comment"><code>Ostap.Combinators.comment</code></a> function and module <code>Reason</code> as reference implementation).</p><p>Additionally some folding can be specified for postfix <code>+</code> and <code>*</code> operators. The folding has the form <b>with {</b> <i>EXPR</i><b>}{</b> <i>EXPR</i> <b>}</b> where the first expression in curved brackets denotes initial value for folding with function given by the second expression. For example</p><pre class="language-ocaml"><code>callee:expression call:(-&quot;(&quot; arguments -&quot;)&quot;)* with{callee}{fun callee args -&gt; `Call (callee, args)} {call}</code></pre><p>is equivalent to</p><pre class="language-ocaml"><code>callee:expression call:(-&quot;(&quot; arguments -&quot;)&quot;)* {List.fold_left (fun callee args -&gt; `Call (callee, args)) callee call}</code></pre><p>Symbol <code>$</code> within parse expression serves as a shortcut for <a href="../../Ostap/Combinators/index.html#val-lift"><code>Ostap.Combinators.lift</code></a> and so delivers underlying stream as its semantic value.</p><p>Prefix operator <code>-</code> is used to <i>omit</i> parsed value from the result of parsing (the parsing of its operand however is not omitted).</p><p>Prefix construct <i>PATT</i><code>:</code> is used to match successfully parsed value against pattern <i>PATT</i>; this matching may provide bindings that can be used later.</p><p>Construct <code>=&gt;{</code><i>EXPR</i><code>}=&gt;</code> is used to supply additional check of successfully parsed value; <i>EXPR</i> has to be of boolean type and may use bindings made before.</p><p>We will not describe the meaning of all constructs in all details since generally it follows the common BNF style; instead we demonstrate some examples that cover all cases of their exploration.</p><p><b>Examples:</b></p><ol><li><p><code>&quot;(&quot; expression &quot;)&quot;</code> is a grammar expression to define a function that matches a stream against successive occurrences of <code>&quot;(&quot;</code>, that that parsed by <code>expression</code>, and <code>&quot;)&quot;</code>. On success this function returns <i>a triple</i>: the token for <code>&quot;(&quot;</code> (of type determined by stream implementation), the value parsed by <code>expression</code>, and the token for <code>&quot;)&quot;</code>. There are generally two ways to exclude <code>&quot;(&quot;</code> and <code>&quot;)&quot;</code> from the result. The first way is to bind the result of <code>expression</code> to some name and then explicitly specify the result of grammar expression as follows:</p><p><code>&quot;(&quot; e:expression &quot;)&quot; {e}</code></p><p>The second is just to say to omit brackets:</p><p><code>-&quot;(&quot; expression -&quot;)&quot;</code>.</p><p>Note that you may specify arbitrary pattern in the left part of binding. Prefix omitting operator &quot;<code>-</code>&quot; may also be applied to any grammar expression, enclosed in brackets.</p></li><li><code>hd:item tl:(-&quot;,&quot; item)* {hd :: tl}</code> defines a function to parse a list of <code>item</code>s.</li><li><code>(s:string {`Str s} | x:integer {`Int x})*</code> defines a function to parse a list of strings or integers.</li><li><code>hd:integer tl:(-(&quot;,&quot;?) integer)* {hd :: tl}</code> parses a list of integers delimited by optional commas.</li><li><code>x:integer =&gt; {x &gt; 0}::(&quot;positive value expected&quot;) =&gt; {x}</code> parses positive integer value.</li><li><code>x:(integer?) =&gt; {match x with Some 0 -&gt; false | _ -&gt; true} =&gt; {x}</code> parses optional non-zero integer value.</li><li><code>x:!(MyParseLibrary.MyModule.parseIt)</code> parses a stream with parse function specified by qualified name.</li></ol><p>In all examples above we assume that <code>integer</code> parses integer value, <code>string</code> --- string value.</p><h3 id="rules"><a href="#rules" class="anchor"></a>Rules</h3><p>Rule is named and optionally parameterized parse expression; several mutually-recursive rules may be defined at once. The syntax of rule definition is</p><p><code>rule</code> <b>:</b> <i>LIDENT</i> <code>arguments</code> <code>:</code> <b>[</b> <code>predicate</code> <b>]</b> <code>parse_expr</code></p><p><code>rules</code> <b>:</b> <code>rule</code><sub>1</sub>; <code>rule</code><sub>2</sub>; ...; <code>rule</code><sub>k</sub></p><p><code>arguments</code> <b>: (</b><code>[</code><i>PATT</i><code>]</code> <b>)*</b></p><p>For example,</p><pre class="language-ocaml"><code>ostap (
  sequence[start]: item[start] | next:item[start] sequence[next];
  item[start]: x:integer {x+start} | &quot;;&quot; {start};
  entry: sequence[0]
)</code></pre><p>declares (among others) the parser function <code>entry</code> which parses and sums a semicolon-terminated sequence of integers.</p><h3 id="documentation-generation"><a href="#documentation-generation" class="anchor"></a>Documentation generation</h3><p>Option <code>-tex </code><i>filename</i> makes <code>Pa_ostap</code> generate <code>LaTeX</code> documentation for all rules. On default all text is placed into specified file; however the output can be split into several files by specifying <code>doc_tag</code> option for <code>ostap</code> construct. The syntax of option is as follows:</p><p><code>doc_tag</code> <b>: [</b> <code>[</code> <i>STRING</i> <code>]</code> <b>]</b></p><p>With this option provided the documentation for corresponding rules will be placed in file with name <i>filename</i><code>.</code><i>tagname</i><code>.tex</code>, where <i>filename</i> is the name specified by option <code>-tex</code> and <i>tagname</i> is string value of <code>doc_tag</code>.</p><p>Generated documentation uses <code>ostap.sty</code> package which provides cross-references and automatic layout for most of the cases. To obtain good documentation it is recommended to use simple parsers (i.e. identifiers) in grammar rules. Parameterized rules are supported as well.</p></div></body></html>
